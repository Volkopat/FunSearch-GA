parents = [{'program_code': "def optimized_bucket_filler(numbers, bucket_limit):\n    from random import shuffle\n\n    def fitness(buckets, bucket_limit):\n        return sum(abs(bucket_limit - sum(bucket)) for bucket in buckets)\n\n    shuffle(numbers)\n    buckets = []\n    for number in numbers:\n        if number > bucket_limit:\n            raise ValueError('Number exceeds the bucket limit')\n        placed = False\n        for bucket in buckets:\n            if (sum(bucket) + number) <= bucket_limit:\n                bucket.append(number)\n                placed = True\n                break\n        if not placed:\n            buckets.append([number])\n\n    initial_fitness = fitness(buckets, bucket_limit)\n\n    for _ in range(100):  # A fixed number of iterations for optimization\n        shuffle(numbers)\n        temp_buckets = []\n        for number in numbers:\n            placed = False\n            for bucket in temp_buckets:\n                if (sum(bucket) + number) <= bucket_limit:\n                    bucket.append(number)\n                    placed = True\n                    break\n            if not placed:\n                temp_buckets.append([number])\n\n        current_fitness = fitness(temp_buckets, bucket_limit)\n        if current_fitness < initial_fitness:\n            buckets = temp_buckets\n            initial_fitness = current_fitness\n\n    return buckets", 'evaluation_results': {'time_taken': 0.005497932434082031, 'memory_used': 0, 'score': 0, 'fitness_score': 49.835963886446606, 'buckets': [[324, 296, 431, 123, 259, 451, 144, 394, 238, 572, 847, 322, 555, 10, 527, 521, 892, 499, 335, 46, 771, 887, 489], [712, 806, 93, 914, 393, 237, 109]]}, 'equation': 'f(B, Limit) = \\sum_{b \\in B}|Limit - \\sum_{x \\in b} x|\n\n\\text{where:}\nB = \\text{Set of all buckets}\nb = \\text{Individual bucket in } B\nLimit = \\text{Bucket limit}', 'pseudocode': 'FUNCTION optimized_bucket_filler(numbers, bucket_limit)\n    IMPORT shuffle from random library\n\n    DEFINE fitness function to calculate the fitness of buckets\n    SHUFFLE numbers randomly\n    INITIALIZE buckets as an empty list\n    FOR each number in shuffled numbers\n        IF number is greater than bucket_limit\n            RAISE ValueError\n        ENDIF\n        INITIALIZE placed as False\n        FOR each bucket in buckets\n            IF sum of bucket and number is less or equal to bucket_limit\n                APPEND number to bucket\n                SET placed to True\n                BREAK\n            ENDIF\n        ENDFOR\n        IF not placed\n            APPEND number to new bucket\n        ENDIF\n    ENDFOR\n\n    CALCULATE initial_fitness using fitness function\n\n    FOR a set number of optimization iterations\n        SHUFFLE numbers\n        INITIALIZE temp_buckets as an empty list identical to main loop logic\n        CALCULATE current_fitness using fitness function\n        IF current_fitness is better than initial_fitness\n            REPLACE buckets with temp_buckets and update initial_fitness\n\n    RETURN buckets\nEND FUNCTION'}, {'program_code': "def optimized_bucket_filler(numbers, bucket_limit):\n    numbers.sort(reverse=True)\n    remaining = sum(numbers)\n    buckets = []\n    current_bucket = []\n    current_sum = 0\n\n    for number in numbers:\n        if number > bucket_limit:\n            raise ValueError('Number exceeds the bucket limit')\n\n        if remaining <= bucket_limit - current_sum:\n            current_bucket += numbers\n            break\n\n        next_number = max(numbers, key=lambda x: min(x, bucket_limit - (current_sum + x)))\n        current_bucket.append(next_number)\n        current_sum += next_number\n        numbers.remove(next_number)\n        remaining -= next_number\n\n        if current_sum == bucket_limit or remaining == 0:\n            buckets.append(current_bucket)\n            current_bucket = []\n            current_sum = 0\n\n    if current_bucket:\n        buckets.append(current_bucket)\n\n    return buckets", 'evaluation_results': {'time_taken': 0.0003101825714111328, 'memory_used': 0, 'score': 928.10167516, 'fitness_score': 96.39578116635946, 'buckets': [[914, 892, 887, 847, 806, 771, 712, 572, 555, 527, 521, 499, 489, 451, 296]]}, 'equation': 'L = \\{x_1, x_2, ..., x_n\\} \\newline B = \\{\\} \\newline b = \\{\\} \\newline S = 0 \\newline R = \\Sigma_{i=1}^{n} x_i \\newline \\forall x \\in L : \\newline \\indent if (x > Limit) : raise Error \\newline \\indent if (R \\leq Limit - S) : \\newline \\indent \\indent b += L \\newline \\indent \\indent break \\newline \\indent next_x = max(L, key=\\lambda y: \\min(y, Limit - (S + y))) \\newline \\indent b.append(next_x) \\newline \\indent S = S + next_x \\newline \\indent L.remove(next_x) \\newline \\indent R = R - next_x \\newline \\indent if (S == Limit) \\lor (R == 0) : \\newline \\indent \\indent B.append(b) \\newline \\indent \\indent b = \\{\\} \\newline \\indent \\indent S = 0 \\newline if (b \\neq \\{\\}) : B.append(b) \\newline return B', 'pseudocode': "FUNCTION optimized_bucket_filler(numbers, bucket_limit)\n    SORT numbers in descending order\n    CALCULATE the sum of all numbers as 'remaining'\n    INITIALIZE buckets as an empty list\n    INITIALIZE current_bucket as an empty list\n    INITIALIZE current_sum to 0\n\n    FOR each number in numbers\n        IF number is greater than bucket_limit\n            RAISE ValueError\n        ENDIF\n\n        IF the sum of the remaining numbers is less or equal to what is allowed to add to the current_bucket\n            ADD remaining numbers to current_bucket and exit loop\n\n        CHOOSE next_number from numbers such that the amount it is filled towards the limit is maximized\n        ADD next_number to current_bucket and update current_sum\n        REMOVE next_number from numbers\n        SUBTRACT next_number value from remaining\n\n        IF current_sum is equal to bucket_limit OR remaining is 0\n            APPEND current_bucket to buckets\n            RESET current_bucket and current_sum\n\n    IF current_bucket is not empty\n        APPEND current_bucket to buckets\n    ENDIF\n\n    RETURN buckets\nEND FUNCTION"}, {'program_code': "def optimized_bucket_filler(numbers, bucket_limit):\n    numbers.sort(reverse=True)\n    buckets = []\n    buckets.append([])\n    len_num = len(numbers)\n    i, j, decremented = 0, 0, False\n\n    while i < len_num:\n        number = numbers[i]\n        current_sum = sum(buckets[j])\n\n        if number > bucket_limit:\n            raise ValueError('Number exceeds the bucket limit')\n\n        if current_sum + number <= bucket_limit:\n            buckets[j].append(number)\n            if decremented:\n                decremented = False\n                i += 1\n        else:\n            if not decremented:\n                decremented = True\n                i -= 1\n            j += 1\n            buckets.append([])\n\n        i += 1\n\n    buckets = [bucket for bucket in buckets if bucket]\n    return buckets", 'evaluation_results': {'time_taken': 4.00543212890625e-05, 'memory_used': 0, 'score': 0, 'fitness_score': 49.998798418489855, 'buckets': [[914, 892, 887, 847, 806, 771, 712, 572, 555, 527, 521, 499, 489, 451, 431], [394, 335, 324, 322, 296, 259, 238, 237, 144, 123, 109, 93, 46, 10]]}, 'equation': 'L = \\{x_1, x_2, ..., x_n\\} \\newline B = \\{\\{\\}\\} \\newline j = 0 \\newline f = \\text{{False}} \\newline i = 0 \\newline n = |L| \\newline \\newline \\text{{while }} i < n \\newline \\indent x = L_i \\newline \\indent S = \\sum (B_j) \\newline \\newline \\indent \\text{{if }} (x > \\text{{Limit}}) : \\text{{ raise Error}} \\newline \\indent \\text{{if }} (S + x \\leq \\text{{Limit}}) : \\newline \\indent \\indent B_j.append(x)  \\newline \\indent \\indent \\text{{if }} (f) : \\newline \\indent \\indent \\indent f = \\text{{False}} \\newline \\indent \\indent \\indent i = i + 1 \\newline \\indent \\text{{else}} : \\newline \\indent \\indent \\text{{if not }} (f) : \\newline \\indent \\indent \\indent f = \\text{{True}} \\newline \\indent \\indent \\indent i = i - 1 \\newline \\indent \\indent j = j + 1 \\newline \\indent \\indent B.append(\\{\\}) \\newline \\newline \\indent i = i + 1 \\newline \\text{{end while}} \\newline \\newline B = \\{ b \\in B | b \\neq \\{\\} \\} \\newline \\text{{return }} B', 'pseudocode': 'FUNCTION optimized_bucket_filler(numbers, bucket_limit)\n    SORT numbers in descending order\n    INITIALIZE buckets as list containing one empty list\n    ASSIGN len_num as length of numbers\n    INITIALIZE i, j to 0 and decremented to False\n\n    WHILE i is less than len_num\n        ASSIGN number as numbers[i]\n        ASSIGN current_sum as sum of buckets[j]\n\n        IF number is greater than bucket_limit\n            RAISE ValueError\n        ENDIF\n\n        IF current_sum + number is less than or equal to bucket_limit\n            APPEND number to buckets[j]\n            IF decremented is True\n                SET decremented to False\n                INCREMENT i\n            ENDIF\n        ELSE\n            IF decremented is False\n                SET decremented to True\n                DECREMENT i\n            ENDIF\n            INCREMENT j\n            APPEND an empty list to buckets\n        ENDIF\n\n        INCREMENT i\n    ENDWHILE\n\n    REMOVE empty lists from buckets\n    RETURN buckets\nEND FUNCTION'}, {'program_code': "def optimized_bucket_filler(numbers, bucket_limit):\n    numbers.sort(reverse=True)\n    buckets = []\n    current_bucket = []\n    current_sum = 0\n\n    for i in range(len(numbers)):\n        if numbers[i] > bucket_limit:\n            raise ValueError('Number exceeds the bucket limit')\n\n        if current_sum + numbers[i] <= bucket_limit:\n            current_bucket.append(numbers[i])\n            current_sum += numbers[i]\n        else:\n            buckets.append(current_bucket)\n            current_bucket = [numbers[i]]\n            current_sum = numbers[i]\n\n        future_sum = current_sum + sum(numbers[i+1:i+3]) # Lookahead\n        if i < len(numbers) - 3 and future_sum > bucket_limit:\n            buckets.append(current_bucket)\n            current_bucket = []\n            current_sum = 0\n\n    if current_bucket:\n        buckets.append(current_bucket)\n\n    return buckets", 'evaluation_results': {'time_taken': 6.508827209472656e-05, 'memory_used': 0, 'score': 0, 'fitness_score': 49.99804747892338, 'buckets': [[914, 892, 887, 847, 806, 771, 712, 572, 555, 527, 521, 499, 489, 451], [431, 394, 393, 335, 324, 322, 296, 259, 238, 237, 144, 123, 109, 93, 46, 10]]}, 'equation': 'L = \\{x_1, x_2, ..., x_n\\} \\newline B = \\{\\} \\newline b = \\{\\} \\newline S = 0 \\newline \\text{for } i = 1 \\text{ to } |L| \\text{ do:} \\newline \\indent \\text{if } (x_i > \\text{Limit}) : \\text{raise Error} \\newline \\indent \\text{if } (S + x_i \\leq \\text{Limit}) : \\newline \\indent \\indent b.append(x_i) \\newline \\indent \\indent S = S + x_i \\newline \\indent \\text{else } : \\newline \\indent \\indent B.append(b) \\newline \\indent \\indent b = \\{x_i\\} \\newline \\indent \\indent S = x_i \\newline \\indent F = S + \\sum_{k=i+1}^{i+3} x_k \\newline \\indent \\text{if } (i < |L| - 3 \\text{ and } F > \\text{Limit}) : \\newline \\indent \\indent B.append(b) \\newline \\indent \\indent b = \\{\\} \\newline \\indent \\indent S = 0 \\newline \\text{end for} \\newline if (b \\neq \\{\\}) : B.append(b) \\newline return B', 'pseudocode': 'FUNCTION optimized_bucket_filler(numbers, bucket_limit)\n    SORT numbers in descending order\n    INITIALIZE buckets as an empty list\n    INITIALIZE current_bucket as an empty list\n    INITIALIZE current_sum to 0\n\n    FOR i from 0 to length of numbers - 1\n        IF numbers[i] is greater than bucket_limit\n            RAISE ValueError\n        ENDIF\n\n        IF current_sum + numbers[i] is less than or equal to bucket_limit\n            APPEND numbers[i] to current_bucket\n            ADD numbers[i] to current_sum\n        ELSE\n            APPEND current_bucket to buckets\n            SET current_bucket to a new list containing numbers[i]\n            SET current_sum to numbers[i]\n        ENDIF\n\n        SET future_sum as current_sum + sum of the next two numbers in the list\n        IF i is less than length of numbers - 3 AND future_sum is greater than bucket_limit\n            APPEND current_bucket to buckets\n            SET current_bucket to an empty list\n            SET current_sum to 0\n        ENDIF\n    ENDFOR\n\n    IF current_bucket is not empty\n        APPEND current_bucket to buckets\n    ENDIF\n\n    RETURN buckets\nEND FUNCTION'}, {'program_code': "def optimized_bucket_filler(numbers, bucket_limit): \n    def first_fit_decreasing(numbers, limit): \n        numbers.sort(reverse=True) \n        bins = [[]] \n        for number in numbers: \n            for b in bins: \n                if sum(b) + number <= limit: \n                    b.append(number) \n                    break \n            else: \n                bins.append([number]) \n        return bins \n \n    def refine_buckets(buckets, limit): \n        buckets.sort(key=lambda b: sum(b), reverse=True) \n        for i in range(len(buckets)): \n            for j in range(i + 1, len(buckets)): \n                space_left = limit - sum(buckets[i]) \n                appendable_items = [x for x in buckets[j] if x <= space_left] \n                if appendable_items: \n                    buckets[i].append(appendable_items[0]) \n                    buckets[j].remove(appendable_items[0]) \n                    if sum(buckets[j]) == 0: \n                        buckets.pop(j) \n                    break \n        return buckets \n \n    if not all(x <= bucket_limit for x in numbers): \n        raise ValueError('Number exceeds the bucket limit') \n    first_draft = first_fit_decreasing(numbers, bucket_limit) \n    refined = refine_buckets(first_draft, bucket_limit) \n    return refined", 'evaluation_results': {'time_taken': 5.984306335449219e-05, 'memory_used': 0, 'score': 0, 'fitness_score': 49.9982048155287, 'buckets': [[914, 892, 887, 847, 806, 771, 712, 572, 555, 527, 521, 499, 489, 451, 431, 123], [394, 393, 335, 324, 322, 296, 259, 238, 237, 144, 109, 93, 46, 10]]}, 'equation': "L = \\{x_1, x_2, ..., x_n\\} \\\\ B = \\{\\} \\\\ first\\_fit\\_decreasing: \\\\ \tSORT L in descending order \\\\ \tB = \\{\\{\\}\\} \\\\ \tFOR x \\in L: \\\\ \t\tFOR b \\in B: \\\\ \t\t\tIF \\sum(b) + x \\leq Limit:\\ \\\\ \t\t\t\tb.append(x) \\\\ \t\t\t\tBREAK \\\\ \t\tIF x \\notin \\bigcup B: \\\\ \t\t\tB.append(\\{x\\}) \\\\ refine\\_buckets: \\\\ \tSORT B by descending \\sum(b)\\'s \\\\ \tFOR i \\in |B|: \\\\ \t\tFOR j \\in |B|, j > i: \\\\ \t\t\tT = Limit - \\sum(B[i]) \\\\ \t\t\tA = \\{x \\in B[j] | x \\leq T\\} \\\\ \t\t\tIF A \\neq \\{\\}: \\\\ \t\t\t\tB[i].append(A[0]) \\\\ \t\t\t\tB[j].remove(A[0]) \\\\ \t\t\t\tIF B[j] = \\{\\}: \\\\ \t\t\t\t\tB.pop(j) \\\\ \t\t\t\tBREAK \\\\ RETURN B", 'pseudocode': 'FUNCTION optimized_bucket_filler(numbers, bucket_limit)\n    FUNCTION first_fit_decreasing(numbers, limit)\n        SORT numbers in descending order\n        INITIALIZE bins as a list containing an empty list\n        FOR each number in numbers\n            FOR each bin in bins\n                IF sum of bin plus number is less than or equal to limit\n                    APPEND number to bin\n                    BREAK loop\n                ENDIF\n            ELSE\n                APPEND a new list containing number to bins\n            ENDFOR\n        ENDFOR\n        RETURN bins\n    ENDFUNCTION\n\n    FUNCTION refine_buckets(buckets, limit)\n        SORT buckets by the sum of their elements in descending order\n        FOR each bucket in buckets\n            FOR each other bucket in buckets starting from the current\n                CALCULATE space_left as limit minus the sum of current bucket\n                IDENTIFY appendable_items from other bucket that would fit in space_left\n                IF appendable_items exist\n                    APPEND the first item of appendable_items to current bucket\n                    REMOVE that item from the other bucket\n                    IF the other bucket is empty after removal\n                        REMOVE the other bucket from buckets\n                    BREAK loop\n                ENDIF\n            ENDFOR\n        ENDFOR\n        RETURN buckets\n    ENDFUNCTION\n\n    IF any number in numbers exceeds bucket_limit\n        RAISE ValueError\n    ENDIF\n\n    INITIALIZE first_draft with the output of first_fit_decreasing(numbers, bucket_limit)\n    INITIALIZE refined with the output of refine_buckets(first_draft, bucket_limit)\n    RETURN refined\nEND FUNCTION'}]

import random
def tournament_selection(parents, tournament_size=3):
    selected_parents = []
    for _ in range(len(parents) - 2):
        tournament = random.sample(parents, tournament_size)
        winner = max(tournament, key=lambda x: x['evaluation_results']['fitness_score'])
        selected_parents.append(winner)
    return selected_parents

def apply_elitism(parents, number_of_elites=2):
    elites = sorted(parents, key=lambda x: x['evaluation_results']['fitness_score'], reverse=True)[:number_of_elites]
    return elites

elite_parents = apply_elitism(parents, number_of_elites=2)
tournament_parents = tournament_selection(parents, tournament_size=3)

print(elite_parents[0]['program_code'])
# print(tournament_parents)